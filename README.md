# goit-algo-hw-09
Жадібні алгоритми та динамічне програмування​

## Опис алгоритмів
* Жадібний обирає наявні монети по черзі від найбільшої до найменшої
* Динамічний бере всі монети, менші за суму решти, та рекурсивно (використовуючи меморізацію) розроховує решту для залишка суми, потім обирає найкращий варіант та формує відповідь


Обидва алгоритма виходять з того, що кількість монет кожного номіналу є необмеженою, та номінали дозволяють видати решту

## Приклад виконання
```
Rest sum is 113
Greedy:  Rest coins {50: 2, 10: 1, 2: 1, 1: 1}
Dinamic: Rest coins {1: 1, 2: 1, 10: 1, 50: 2}
Analyze time: for greedy algorithm 0.000003019 and for dinamic algorithm 0.000598300

Rest sum is 7913
Greedy:  Rest coins {50: 158, 10: 1, 2: 1, 1: 1}
Dinamic: Rest coins {1: 1, 2: 1, 10: 1, 50: 158}
Analyze time: for greedy algorithm 0.000002433 and for dinamic algorithm 0.045302310

Rest sum is 15226
Greedy:  Rest coins {50: 304, 25: 1, 1: 1}
Dinamic: Rest coins {1: 1, 25: 1, 50: 304}
Analyze time: for greedy algorithm 0.000002023 and for dinamic algorithm 0.082859039

Rest sum is 15226234
Greedy:  Rest coins {50: 304524, 25: 1, 5: 1, 2: 2}

RecursionError: maximum recursion depth exceeded in comparison

 ```

## Висновки
* Жадібна стратегія є оптимальною? за умови відсутності обмеження на кількість монет кожного з номіналів
* Наведений динамічний алгоритм не може обчислити решту для великої суми через обмеження стеку рекурсії (що не є недоліком для практичних застосувань, через невеликі реальні суми решти)
* Динамічний алгоритм значно повільніший за жадібний
* Складність жадібного алгоритму залежить від кількості номіналів
* Складність динамічного алгоритму залежить від суми решти
